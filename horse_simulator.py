#!/usr/bin/env python
# -*- coding: utf-8 -*-

import random


def kind_of_course():
    """
    This function ask user what kind of course does he want
    :return: the desired kind of course
    """
    while True:
        user_choice = int(input("What kind of course do you want? 3,4 or 5?"))
        if user_choice == 3:
            return 3
        elif user_choice == 4:
            return 4
        elif user_choice == 5:
            return 5
        else:
            print("That is not a valid choice")


def roll_dice():
    """
    This fonction simulate a random dice roll between 1 and 6.
    :return: a number between 1 and 6.
    """
    random_number = random.randint(1,6)
    return random_number


def generate_list(horse_number):
    """
    This function generates a list of horse (dict)

    :param horse_number: the number of horses chosen by user.
    :return: a list of dictionaries where each dictionary represents one horse.
    """
    horse_list = []
    for i in range(horse_number):
        horse_list.append({'horse': i + 1 , 'position': 0 , 'history': [], 'actual speed':0, 'disqualified': False})
    return horse_list


def simulate_course(horse_l):
    """
    This function simulates a course for each horse,
    every turn, rolling a dice that will determinate the distance
    the horse will do.
    :param horse_l: the list of dictionaries where each dictionary represents one horse.
    :return: the final ranking
    """
    turn = 0

    # The rules about speed and modifiers
    rolling_dice = [
        {'actual speed': 0, 'speed1': 0, 'speed2': +1, 'speed3': +1, 'speed4': +1, 'speed5': +2, 'speed6': +2},
        {'actual speed': 1, 'speed1': 0, 'speed2': 0, 'speed3': +1, 'speed4': +1, 'speed5': +1, 'speed6': +2},
        {'actual speed': 2, 'speed1': 0, 'speed2': 0, 'speed3': +1, 'speed4': +1, 'speed5': +1, 'speed6': +2},
        {'actual speed': 3, 'speed1': -1, 'speed2': 0, 'speed3': 0, 'speed4': +1, 'speed5': +1, 'speed6': +1},
        {'actual speed': 4, 'speed1': -1, 'speed2': 0, 'speed3': 0, 'speed4': 0, 'speed5': +1, 'speed6': +1},
        {'actual speed': 5, 'speed1': -2, 'speed2': -1, 'speed3': 0, 'speed4': 0, 'speed5': 0, 'speed6': +1},
        {'actual speed': 6, 'speed1': -2, 'speed2': -1, 'speed3': 0, 'speed4': 0, 'speed5': 0, 'speed6': 'DQ'}]

    # A dict with correspondance between speed and distance
    base_speed = {0: 0, 1: 23, 2: 46, 3: 69, 4: 92, 5: 115, 6: 138}

    while any(not horse.get('disqualified', False) and horse['position'] < 2400 for horse in horse_l):
        turn += 1
        print(f"\n--- Turn {turn} ---")
        choice = input("Press Enter to continue to the next turn (or type 'q' to quit): ")
        if choice == 'q':
            break
        else:
            active_horses = []
            for horse in horse_l:
                if horse['position'] >= 2400:
                    active_horses.append(horse)
                    continue

                dice = roll_dice()
                current_speed = min(horse['actual speed'],6)
                modifiers = rolling_dice[current_speed]
                key = f'speed{dice}'
                modified_speed = modifiers[key]

                if modified_speed  == 'DQ':
                    print(f"Horse {horse['horse']} disqualified on turn {turn}")
                    horse['disqualified'] = True
                    # We continue to not add the disqualified horses to our list
                    continue

                adjusted_speed = dice + modified_speed
                adjusted_speed = max(1, min(adjusted_speed, 6))

                distance = base_speed[adjusted_speed]
                horse['actual speed'] = adjusted_speed
                horse['position'] += distance
                horse['history'].append(distance)

                active_horses.append(horse)

                #print(f"Horse {horse['horse']} rolled {dice} → speed {adjusted_speed} → moved {distance}m → total {horse['position']}m")

        horse_l = active_horses

        # We sort the list and print it, so we can see which horse is ahead
        # each turn
        print("\nPositions après ce tour :")
        sorted_horses = sorted(horse_l, key=lambda horse: horse['position'], reverse=True)
        for h in sorted_horses:
            status = "DISQUALIFIED" if h['disqualified'] else f"{h['position']}m"
            print(f"Horse {h['horse']:2} → {status}")

    ranking = sorted(horse_l, key = lambda horse: horse['position'], reverse = True)
    return ranking


def print_out(rank,type_of_c):
    """
    This function prints out the final ranking.
    :param rank: the ranking generated by simulate_course()
    :param type_of_c: type of course (tiercé, quarté or quinté)
    :return: formated ranking
    """
    print('========================Course ended!========================')
    for index, horse in enumerate(rank[:type_of_c]):
        print(f'{index+1:2}. Horse : {horse["horse"]:2}  -> position: {horse["position"]}')


def main():
    """
    This is the main function.
    :return:
    """
    while True:
        number_of_horses = int(input("How many horses do you want to simulate? (12-20): "))
        if 12 <= number_of_horses <= 20:
            break
        else:
            print("That is not a valid choice. Please try again. A number between 12 and 20")

    horse_list = generate_list(number_of_horses)
    k = kind_of_course()
    ranking = simulate_course(horse_list)
    print_out(ranking, k)


if __name__=='__main__':
    main()